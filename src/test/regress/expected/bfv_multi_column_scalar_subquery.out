-----------------------------------------------
-- Testcases regarding multi-column scalar subqueries --
-----------------------------------------------
-- Setup
-- start_ignore
drop table if exists t1_subq;
NOTICE:  table "t1_subq" does not exist, skipping
drop table if exists t2_subq;
NOTICE:  table "t2_subq" does not exist, skipping
drop table if exists t3_subq;
NOTICE:  table "t3_subq" does not exist, skipping
drop table if exists composite_table;
NOTICE:  table "composite_table" does not exist, skipping
create table t1_subq (a int, b int, c int) distributed by (a);
create table t2_subq (a int, b int, c int) distributed by (a);
create table t3_subq (a int, b int, c int) distributed by (a);
create type composite_type as ( a int, b int);
create table composite_table(id int, item composite_type) distributed by (id);
-- end_ignore
insert into t1_subq values (1, 1, null), (2, 1, 1), (1, null, 1), (2, null, 1), (1,1,1), (1,1,0), (0,0,0);
insert into t2_subq values (1, null, 1), ('123', 456, null), (1, 1, null), (1, 1, 1), (1, 1, 0), (0,0,0);
insert into t3_subq values (1, 1, null), ('123', 456, null), (1, 1, null);
insert into composite_table values (1, ROW(1, 10)), (2, ROW(2, 20));
analyze t1_subq, t2_subq, t3_subq;
set optimizer_trace_fallback to on;
----------------------------------------------------
------- multi-column scalar IN subqueries ----------
----------------------------------------------------
-- Two columns composite key
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.b, t1_subq.c from t2_subq);
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         ->  Seq Scan on t1_subq
               Filter: ((a = b) AND (b = c))
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.b, t1_subq.c from t2_subq);
 a | b | c 
---+---+---
 1 | 1 | 1
 0 | 0 | 0
(2 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a, t2_subq.b from t2_subq);
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: ((t1_subq.a = t2_subq.a) AND (t1_subq.b = t2_subq.b))
         ->  Seq Scan on t1_subq
         ->  Hash
               ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(7 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a, t2_subq.b from t2_subq);
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(4 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a, t1_subq.b from t2_subq);
                 QUERY PLAN                 
--------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: (t1_subq.a = t2_subq.a)
         ->  Seq Scan on t1_subq
               Filter: (b IS NOT NULL)
         ->  Hash
               ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a, t1_subq.b from t2_subq);
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(4 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.b, t1_subq.c from t2_subq) AND t1_subq.b=1;
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         ->  Seq Scan on t1_subq
               Filter: ((b = 1) AND (a = 1) AND (c = 1))
         ->  Materialize
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: 1
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.b, t1_subq.c from t2_subq) AND t1_subq.b=1;
 a | b | c 
---+---+---
 1 | 1 | 1
(1 row)

explain (costs off)  select * from t1_subq where (a, b) IN (select (item).a, (item).b from composite_table);
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  HashAggregate
         Group Key: (RowIdExpr)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: (RowIdExpr)
               ->  Hash Join
                     Hash Cond: (((composite_table.item).a = t1_subq.a) AND ((composite_table.item).b = t1_subq.b))
                     ->  Seq Scan on composite_table
                     ->  Hash
                           ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                 ->  Seq Scan on t1_subq
 Optimizer: Postgres-based planner
(12 rows)

select * from t1_subq where (a, b) IN (select (item).a, (item).b from composite_table);
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) IN (select a, b from t3_subq);
                           QUERY PLAN                            
-----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3_subq.b = t2_subq.a)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: t3_subq.b
               ->  Hash Join
                     Hash Cond: (t1_subq.a = t3_subq.a)
                     ->  Seq Scan on t1_subq
                     ->  Hash
                           ->  HashAggregate
                                 Group Key: t3_subq.a, t3_subq.b
                                 ->  Seq Scan on t3_subq
         ->  Hash
               ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(15 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) IN (select a, b from t3_subq);
 a | b | c | a | b | c 
---+---+---+---+---+---
 1 | 1 |   | 1 | 1 | 0
 1 | 1 |   | 1 | 1 | 1
 1 | 1 |   | 1 | 1 |  
 1 | 1 |   | 1 |   | 1
 1 |   | 1 | 1 | 1 | 0
 1 |   | 1 | 1 | 1 | 1
 1 |   | 1 | 1 | 1 |  
 1 |   | 1 | 1 |   | 1
 1 | 1 | 1 | 1 | 1 | 0
 1 | 1 | 1 | 1 | 1 | 1
 1 | 1 | 1 | 1 | 1 |  
 1 | 1 | 1 | 1 |   | 1
 1 | 1 | 0 | 1 | 1 | 0
 1 | 1 | 0 | 1 | 1 | 1
 1 | 1 | 0 | 1 | 1 |  
 1 | 1 | 0 | 1 |   | 1
(16 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t1_subq.a from t3_subq);
                             QUERY PLAN                              
---------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  HashAggregate
         Group Key: (RowIdExpr)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: (RowIdExpr)
               ->  Nested Loop
                     ->  Broadcast Motion 3:3  (slice3; segments: 3)
                           ->  Hash Join
                                 Hash Cond: (t1_subq.a = t2_subq.a)
                                 ->  Seq Scan on t1_subq
                                 ->  Hash
                                       ->  Seq Scan on t2_subq
                     ->  Materialize
                           ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(15 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t1_subq.a from t3_subq);
 a | b | c | a | b | c 
---+---+---+---+---+---
 1 |   | 1 | 1 | 1 |  
 1 | 1 | 1 | 1 |   | 1
 1 | 1 | 0 | 1 | 1 | 0
 1 | 1 | 1 | 1 | 1 | 1
 1 |   | 1 | 1 | 1 | 0
 1 | 1 |   | 1 | 1 |  
 0 | 0 | 0 | 0 | 0 | 0
 1 | 1 | 0 | 1 |   | 1
 1 | 1 |   | 1 | 1 | 1
 1 | 1 | 0 | 1 | 1 |  
 1 |   | 1 | 1 |   | 1
 1 |   | 1 | 1 | 1 | 1
 1 | 1 |   | 1 | 1 | 0
 1 | 1 | 1 | 1 | 1 | 0
 1 | 1 | 0 | 1 | 1 | 1
 1 | 1 | 1 | 1 | 1 |  
 1 | 1 |   | 1 |   | 1
(17 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t3_subq.a from t3_subq);
                    QUERY PLAN                    
--------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: (t1_subq.a = t3_subq.a)
         ->  Hash Join
               Hash Cond: (t1_subq.a = t2_subq.a)
               ->  Seq Scan on t1_subq
               ->  Hash
                     ->  Seq Scan on t2_subq
         ->  Hash
               ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(11 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t3_subq.a from t3_subq);
 a | b | c | a | b | c 
---+---+---+---+---+---
 1 | 1 |   | 1 | 1 | 0
 1 | 1 |   | 1 | 1 | 1
 1 | 1 |   | 1 | 1 |  
 1 | 1 |   | 1 |   | 1
 1 |   | 1 | 1 | 1 | 0
 1 |   | 1 | 1 | 1 | 1
 1 |   | 1 | 1 | 1 |  
 1 |   | 1 | 1 |   | 1
 1 | 1 | 1 | 1 | 1 | 0
 1 | 1 | 1 | 1 | 1 | 1
 1 | 1 | 1 | 1 | 1 |  
 1 | 1 | 1 | 1 |   | 1
 1 | 1 | 0 | 1 | 1 | 0
 1 | 1 | 0 | 1 | 1 | 1
 1 | 1 | 0 | 1 | 1 |  
 1 | 1 | 0 | 1 |   | 1
(16 rows)

    -- subquery in value context
explain (costs off) select ((t1_subq.a, t1_subq.b) IN (select t1_subq.a, t1_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) IN (select t1_subq.a, t1_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 
 t
 
 t
 t
 t
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) IN (select t2_subq.a, t2_subq.b from t2_subq)) from t1_subq;
                        QUERY PLAN                         
-----------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Broadcast Motion 3:3  (slice2; segments: 3)
                 ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(6 rows)

select ((t1_subq.a, t1_subq.b) IN (select t2_subq.a, t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 t
 
 t
 t
 t
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) IN (select t1_subq.a, t2_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) IN (select t1_subq.a, t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 
 t
 
 t
 t
 t
(7 rows)

explain (costs off)  select ((a, b) IN (select (item).a, (item).b from composite_table)) from t1_subq;
                        QUERY PLAN                         
-----------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Broadcast Motion 3:3  (slice2; segments: 3)
                 ->  Seq Scan on composite_table
 Optimizer: Postgres-based planner
(6 rows)

select ((a, b) IN (select (item).a, (item).b from composite_table)) from t1_subq;
 ?column? 
----------
 f
 
 f
 f
 f
 f
 
(7 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) IN (select a, b from t3_subq) from t1_subq, t2_subq;
                        QUERY PLAN                         
-----------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice3; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Broadcast Motion 3:3  (slice2; segments: 3)
                 ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(10 rows)

select (t1_subq.a, t2_subq.a) IN (select a, b from t3_subq) from t1_subq, t2_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 f
 f
 f
 f
 f
(42 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t1_subq.a from t3_subq) from t1_subq, t2_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice3; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(12 rows)

select (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t1_subq.a from t3_subq) from t1_subq, t2_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 f
 f
 f
 f
 t
(42 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t3_subq.a from t3_subq) from t1_subq, t2_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice3; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(12 rows)

select (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t3_subq.a from t3_subq) from t1_subq, t2_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
(42 rows)

-- Three columns composite key
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq);
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         ->  Seq Scan on t1_subq
               Filter: ((a = b) AND (b = c))
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq);
 a | b | c 
---+---+---
 1 | 1 | 1
 0 | 0 | 0
(2 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: ((t1_subq.a = t2_subq.a) AND (t1_subq.b = t2_subq.b) AND (t1_subq.c = t2_subq.c))
         ->  Seq Scan on t1_subq
         ->  Hash
               ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(7 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq);
 a | b | c 
---+---+---
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(3 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq);
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: (t1_subq.a = t2_subq.b)
         ->  Seq Scan on t1_subq
               Filter: ((a = b) AND (b = c))
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: t2_subq.b
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(10 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq);
 a | b | c 
---+---+---
 1 | 1 | 1
 0 | 0 | 0
(2 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq) AND t1_subq.b=1;
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         ->  Seq Scan on t1_subq
               Filter: ((b = 1) AND (a = 1) AND (c = 1))
         ->  Materialize
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: 1
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq) AND t1_subq.b=1;
 a | b | c 
---+---+---
 1 | 1 | 1
(1 row)

    -- subquery in value context
explain (costs off) select ((t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 
 
 t
 f
 t
 f
 
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b, t1_subq.c) IN (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq)) from t1_subq;
                        QUERY PLAN                         
-----------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Broadcast Motion 3:3  (slice2; segments: 3)
                 ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(6 rows)

select ((t1_subq.a, t1_subq.b, t1_subq.c) IN (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 
 
 t
 t
 t
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 
 
 
 t
 f
 t
(7 rows)

-- Adding const to projection column
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.c+1, t1_subq.c+1 from t2_subq);
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         ->  Seq Scan on t1_subq
               Filter: ((a = (c + 1)) AND ((c + 1) = b))
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.c+1, t1_subq.c+1 from t2_subq);
 a | b | c 
---+---+---
 1 | 1 | 0
(1 row)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.c+1, t2_subq.c+1 from t2_subq);
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: (t1_subq.a = (t2_subq.c + 1))
         ->  Seq Scan on t1_subq
               Filter: (a = b)
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: (t2_subq.c + 1)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(10 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.c+1, t2_subq.c+1 from t2_subq);
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
(3 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a+1, t2_subq.b+1 from t2_subq);
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: (t1_subq.b = (t2_subq.b + 1))
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: t1_subq.b
               ->  Seq Scan on t1_subq
                     Filter: (a = (a + 1))
         ->  Hash
               ->  Redistribute Motion 3:3  (slice3; segments: 3)
                     Hash Key: (t2_subq.b + 1)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a+1, t2_subq.b+1 from t2_subq);
 a | b | c 
---+---+---
(0 rows)

    -- subquery in value context
explain (costs off) select ((t1_subq.a, t1_subq.b) IN (select t1_subq.c+1, t1_subq.c+1 from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) IN (select t1_subq.c+1, t1_subq.c+1 from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 
 
 f
 f
 t
 f
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) IN (select t2_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
                        QUERY PLAN                         
-----------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Broadcast Motion 3:3  (slice2; segments: 3)
                 ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(6 rows)

select ((t1_subq.a, t1_subq.b) IN (select t2_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
 ?column? 
----------
 
 
 t
 
 t
 t
 
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) IN (select t1_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) IN (select t1_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 
 
 f
 f
 t
 f
(7 rows)

-- Adding two columns
   -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq);
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         ->  Seq Scan on t1_subq
               Filter: ((a = (a + a)) AND (b = (b + b)))
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq);
 a | b | c 
---+---+---
 0 | 0 | 0
(1 row)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: ((t1_subq.a = (t2_subq.a + t2_subq.a)) AND (t1_subq.b = (t2_subq.b + t2_subq.b)))
         ->  Seq Scan on t1_subq
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: (t2_subq.a + t2_subq.a)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq);
 a | b | c 
---+---+---
 0 | 0 | 0
(1 row)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq);
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  HashAggregate
         Group Key: (RowIdExpr)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: (RowIdExpr)
               ->  Nested Loop
                     Join Filter: (((t1_subq.a + t2_subq.a) = t1_subq.a) AND ((t1_subq.b + t2_subq.b) = t1_subq.b))
                     ->  Broadcast Motion 3:3  (slice3; segments: 3)
                           ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq);
 a | b | c 
---+---+---
 2 | 1 | 1
 1 | 1 | 0
 1 | 1 |  
 0 | 0 | 0
 1 | 1 | 1
(5 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b) = ANY(select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b) = ANY(select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 t
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b) = ANY(select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq)) from t1_subq;
                        QUERY PLAN                         
-----------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Broadcast Motion 3:3  (slice2; segments: 3)
                 ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(6 rows)

select  ((t1_subq.a, t1_subq.b) = ANY(select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 
 
 f
 f
 f
 f
 t
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b) = ANY(select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b) = ANY(select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 
 t
 
 t
 t
 t
(7 rows)

-- Nested subquery
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a,t1_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Hash Semi Join
                                   Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                                   ->  Seq Scan on t2_subq
                                   ->  Hash
                                         ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(13 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a,t1_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
 a | b | c 
---+---+---
 2 | 1 | 1
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(5 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: ((t1_subq.a = t2_subq.a) AND (t1_subq.b = t2_subq.b))
         ->  Seq Scan on t1_subq
         ->  Hash
               ->  Hash Semi Join
                     Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                     ->  Seq Scan on t2_subq
                     ->  Hash
                           ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(11 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
(3 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq));
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Hash Semi Join
                 Hash Cond: (t2_subq.a = t3_subq.a)
                 ->  Result
                       Filter: (t2_subq.b = t1_subq.b)
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   ->  Seq Scan on t2_subq
                 ->  Hash
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                   ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(16 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq));
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
(3 rows)

    -- subquery in value context
explain (costs off) select (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq)) from t1_subq;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Broadcast Motion 3:3  (slice2; segments: 3)
                 ->  Hash Semi Join
                       Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                       ->  Seq Scan on t2_subq
                       ->  Hash
                             ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(10 rows)

select (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq)) from t1_subq;
 ?column? 
----------
 t
 
 t
 t
 f
 f
 f
(7 rows)

explain (costs off) select (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq)) from t1_subq;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Hash Semi Join
                 Hash Cond: (t2_subq.a = t3_subq.a)
                 ->  Result
                       Filter: (t2_subq.b = t1_subq.b)
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   ->  Seq Scan on t2_subq
                 ->  Hash
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                   ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(15 rows)

select (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq)) from t1_subq;
 ?column? 
----------
 t
 f
 t
 t
 f
 f
 f
(7 rows)

-- Set returning function in projection
   -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select generate_series(1, 10), generate_series(1, 10));
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: ((t1_subq.a = (generate_series(1, 10))) AND (t1_subq.b = (generate_series(1, 10))))
         ->  Seq Scan on t1_subq
         ->  Hash
               ->  ProjectSet
                     ->  Result
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select generate_series(1, 10), generate_series(1, 10));
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
(3 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b) IN (select generate_series(1, 10), generate_series(1, 10))) from t1_subq;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  ProjectSet
                 ->  Result
 Optimizer: Postgres-based planner
(6 rows)

select  ((t1_subq.a, t1_subq.b) IN (select generate_series(1, 10), generate_series(1, 10))) from t1_subq;
 ?column? 
----------
 f
 
 t
 
 t
 t
 f
(7 rows)

-----------------------------------------------------
------- multi-column scalar ALL subqueries ----------
-----------------------------------------------------
-- Two columns composite key
   -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t1_subq.b from t2_subq);
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t1_subq.b from t2_subq);
 a | b | c 
---+---+---
 2 | 1 | 1
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(5 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a, t2_subq.b from t2_subq);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a, t2_subq.b from t2_subq);
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t2_subq.b from t2_subq);
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t2_subq.b from t2_subq);
 a | b | c 
---+---+---
(0 rows)

explain (costs off)  select * from t1_subq where (a, b) = ALL (select (item).a, (item).b from composite_table);
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((t1_subq.a <> (composite_table.item).a) OR (t1_subq.b <> (composite_table.item).b))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on composite_table
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (a, b) = ALL (select (item).a, (item).b from composite_table);
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) = ALL (select a, b from t3_subq);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((t1_subq.a <> t3_subq.a) OR (t2_subq.a <> t3_subq.b))
         ->  Nested Loop
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
               ->  Materialize
                     ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice3; segments: 3)
                     ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(12 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) = ALL (select a, b from t3_subq);
 a | b | c | a | b | c 
---+---+---+---+---+---
(0 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t1_subq.a from t3_subq);
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         Join Filter: (SubPlan 1)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice3; segments: 3)
                             ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(13 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t1_subq.a from t3_subq);
 a | b | c | a | b | c 
---+---+---+---+---+---
 1 | 1 |   | 1 |   | 1
 1 |   | 1 | 1 |   | 1
 1 | 1 | 1 | 1 |   | 1
 1 | 1 | 0 | 1 |   | 1
 1 | 1 |   | 1 | 1 |  
 1 |   | 1 | 1 | 1 |  
 1 | 1 | 1 | 1 | 1 |  
 1 | 1 | 0 | 1 | 1 |  
 1 | 1 |   | 1 | 1 | 1
 1 |   | 1 | 1 | 1 | 1
 1 | 1 | 1 | 1 | 1 | 1
 1 | 1 | 0 | 1 | 1 | 1
 1 | 1 |   | 1 | 1 | 0
 1 |   | 1 | 1 | 1 | 0
 1 | 1 | 1 | 1 | 1 | 0
 1 | 1 | 0 | 1 | 1 | 0
 0 | 0 | 0 | 0 | 0 | 0
(17 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t3_subq.a from t3_subq);
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         Join Filter: (SubPlan 1)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice3; segments: 3)
                             ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(13 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t3_subq.a from t3_subq);
 a | b | c | a | b | c 
---+---+---+---+---+---
(0 rows)

    -- subquery in value context
explain (costs off) select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t1_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t1_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 
 t
 
 t
 t
 t
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) = ALL (select t2_subq.a, t2_subq.b from t2_subq)) from t1_subq;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                       ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(7 rows)

select ((t1_subq.a, t1_subq.b) = ALL (select t2_subq.a, t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t2_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 
 f
 
 f
 f
 f
(7 rows)

explain (costs off) select ((a, b) = ALL (select (item).a, (item).b from composite_table)) from t1_subq;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                       ->  Seq Scan on composite_table
 Optimizer: Postgres-based planner
(7 rows)

select ((a, b) = ALL (select (item).a, (item).b from composite_table)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) = ALL (select a, b from t3_subq) from t1_subq, t2_subq;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice3; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                       ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(11 rows)

select (t1_subq.a, t2_subq.a) = ALL (select a, b from t3_subq) from t1_subq, t2_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
(42 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t1_subq.a from t3_subq) from t1_subq, t2_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice3; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(12 rows)

select (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t1_subq.a from t3_subq) from t1_subq, t2_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 f
 f
 f
 f
 t
(42 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t3_subq.a from t3_subq) from t1_subq, t2_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice3; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(12 rows)

select (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t3_subq.a from t3_subq) from t1_subq, t2_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
(42 rows)

-- Three columns composite key
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq);
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq);
 a | b | c 
---+---+---
 1 | 1 | 1
 0 | 0 | 0
(2 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b) OR (t1_subq.c <> t2_subq.c))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq);
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq);
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq);
 a | b | c 
---+---+---
(0 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 
 
 
 t
 f
 t
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq)) from t1_subq;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                       ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(7 rows)

select  ((t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 
 f
 f
 f
 f
 f
 f
(7 rows)

-- Adding const to projection column
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL(select t1_subq.c+1, t1_subq.c+1 from t2_subq);
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL(select t1_subq.c+1, t1_subq.c+1 from t2_subq);
 a | b | c 
---+---+---
 1 | 1 | 0
(1 row)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL(select t2_subq.c+1, t2_subq.c+1 from t2_subq);
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((t1_subq.a <> (t2_subq.c + 1)) OR (t1_subq.b <> (t2_subq.c + 1)))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL(select t2_subq.c+1, t2_subq.c+1 from t2_subq);
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL(select t1_subq.a+1, t2_subq.b+1 from t2_subq);
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL(select t1_subq.a+1, t2_subq.b+1 from t2_subq);
 a | b | c 
---+---+---
(0 rows)

    -- subquery in value context
explain (costs off) select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.c+1, t1_subq.c+1 from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.c+1, t1_subq.c+1 from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 
 
 f
 f
 t
 f
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) = ALL (select t2_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                       ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(7 rows)

select ((t1_subq.a, t1_subq.b) = ALL (select t2_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 
 f
 f
 f
 f
 f
(7 rows)

-- Adding two columns
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq);
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq);
 a | b | c 
---+---+---
 0 | 0 | 0
(1 row)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((t1_subq.a <> (t2_subq.a + t2_subq.a)) OR (t1_subq.b <> (t2_subq.b + t2_subq.b)))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq);
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq);
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq);
 a | b | c 
---+---+---
(0 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 t
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b) = ALL (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq)) from t1_subq;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                       ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(7 rows)

select  ((t1_subq.a, t1_subq.b) = ALL (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

-- Nested subquery
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a,t1_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Hash Semi Join
                                   Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                                   ->  Seq Scan on t2_subq
                                   ->  Hash
                                         ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(13 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a,t1_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
 a | b | c 
---+---+---
 2 | 1 | 1
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(5 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Semi Join
                           Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                           ->  Seq Scan on t2_subq
                           ->  Hash
                                 ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq));
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Hash Semi Join
                 Hash Cond: (t2_subq.a = t3_subq.a)
                 ->  Result
                       Filter: (t2_subq.b = t1_subq.b)
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   ->  Seq Scan on t2_subq
                 ->  Hash
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                   ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(16 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq));
 a | b | c 
---+---+---
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
 2 |   | 1
(6 rows)

    -- subquery in value context
explain (costs off) select (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq)) from t1_subq;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                       ->  Hash Semi Join
                             Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                             ->  Seq Scan on t2_subq
                             ->  Hash
                                   ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(11 rows)

select (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

explain (costs off) select (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq)) from t1_subq;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Hash Semi Join
                 Hash Cond: (t2_subq.a = t3_subq.a)
                 ->  Result
                       Filter: (t2_subq.b = t1_subq.b)
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   ->  Seq Scan on t2_subq
                 ->  Hash
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                   ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(15 rows)

select (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq)) from t1_subq;
 ?column? 
----------
 f
 t
 t
 t
 t
 t
 t
(7 rows)

-- Set returning function in projection
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select generate_series(1, 10), generate_series(1, 10));
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((t1_subq.a <> (generate_series(1, 10))) OR (t1_subq.b <> (generate_series(1, 10))))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  ProjectSet
                     ->  Result
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select generate_series(1, 10), generate_series(1, 10));
 a | b | c 
---+---+---
(0 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b) = ALL (select generate_series(1, 10), generate_series(1, 10))) from t1_subq;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  ProjectSet
                       ->  Result
 Optimizer: Postgres-based planner
(7 rows)

select  ((t1_subq.a, t1_subq.b) = ALL (select generate_series(1, 10), generate_series(1, 10))) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

--------------------------------------------------------
------- multi-column scalar != ANY subqueries ----------
--------------------------------------------------------
-- Two columns composite key
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t1_subq.b from t2_subq);
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         ->  Seq Scan on t1_subq
               Filter: ((a <> a) OR (b <> b))
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t1_subq.b from t2_subq);
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a, t2_subq.b from t2_subq);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a, t2_subq.b from t2_subq);
 a | b | c 
---+---+---
 2 | 1 | 1
 2 |   | 1
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(7 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t2_subq.b from t2_subq);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> t1_subq.a) OR (t1_subq.b <> t2_subq.b))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t2_subq.b from t2_subq);
 a | b | c 
---+---+---
 2 | 1 | 1
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(5 rows)

explain (costs off)  select * from t1_subq where (a, b) != any(select (item).a, (item).b from composite_table);
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> (composite_table.item).a) OR (t1_subq.b <> (composite_table.item).b))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on composite_table
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (a, b) != any(select (item).a, (item).b from composite_table);
 a | b | c 
---+---+---
 2 | 1 | 1
 2 |   | 1
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(7 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) != ANY (select a, b from t3_subq);
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  HashAggregate
         Group Key: (RowIdExpr)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: (RowIdExpr)
               ->  Nested Loop
                     Join Filter: ((t1_subq.a <> t3_subq.a) OR (t2_subq.a <> t3_subq.b))
                     ->  Broadcast Motion 3:3  (slice3; segments: 3)
                           ->  Nested Loop
                                 ->  Broadcast Motion 3:3  (slice4; segments: 3)
                                       ->  Seq Scan on t2_subq
                                 ->  Materialize
                                       ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(16 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) != ANY (select a, b from t3_subq);
 a | b | c |  a  |  b  | c 
---+---+---+-----+-----+---
 2 |   | 1 |   1 |   1 | 0
 1 | 1 | 0 |   1 |     | 1
 0 | 0 | 0 |   1 |   1 | 0
 2 | 1 | 1 |   1 |   1 | 1
 2 | 1 | 1 |   1 |   1 | 0
 1 | 1 |   |   1 |   1 |  
 1 | 1 | 0 | 123 | 456 |  
 2 |   | 1 |   1 |     | 1
 1 | 1 | 1 |   1 |     | 1
 0 | 0 | 0 |   1 |   1 | 1
 0 | 0 | 0 |   1 |   1 |  
 1 | 1 |   |   1 |     | 1
 1 | 1 |   | 123 | 456 |  
 1 | 1 | 0 |   1 |   1 |  
 2 |   | 1 |   1 |   1 | 1
 2 |   | 1 |   0 |   0 | 0
 1 | 1 | 1 |   1 |   1 | 0
 2 |   | 1 | 123 | 456 |  
 2 | 1 | 1 | 123 | 456 |  
 1 | 1 | 0 |   1 |   1 | 0
 1 | 1 |   |   1 |   1 | 0
 1 | 1 | 0 |   0 |   0 | 0
 1 |   | 1 |   1 |     | 1
 1 |   | 1 |   0 |   0 | 0
 1 |   | 1 |   1 |   1 |  
 1 |   | 1 |   1 |   1 | 0
 1 | 1 | 1 |   1 |   1 |  
 1 | 1 |   |   0 |   0 | 0
 2 | 1 | 1 |   1 |     | 1
 1 | 1 | 0 |   1 |   1 | 1
 2 |   | 1 |   1 |   1 |  
 0 | 0 | 0 |   0 |   0 | 0
 2 | 1 | 1 |   0 |   0 | 0
 1 | 1 | 1 |   1 |   1 | 1
 1 |   | 1 |   1 |   1 | 1
 1 | 1 |   |   1 |   1 | 1
 1 |   | 1 | 123 | 456 |  
 0 | 0 | 0 |   1 |     | 1
 0 | 0 | 0 | 123 | 456 |  
 2 | 1 | 1 |   1 |   1 |  
 1 | 1 | 1 | 123 | 456 |  
 1 | 1 | 1 |   0 |   0 | 0
(42 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t1_subq.a from t3_subq);
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  HashAggregate
         Group Key: (RowIdExpr)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: (RowIdExpr)
               ->  Nested Loop
                     ->  Broadcast Motion 3:3  (slice3; segments: 3)
                           ->  Nested Loop
                                 Join Filter: ((t1_subq.a <> t2_subq.a) OR (t2_subq.a <> t1_subq.a))
                                 ->  Broadcast Motion 3:3  (slice4; segments: 3)
                                       ->  Seq Scan on t2_subq
                                 ->  Materialize
                                       ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(16 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t1_subq.a from t3_subq);
 a | b | c |  a  |  b  | c 
---+---+---+-----+-----+---
 2 |   | 1 |   1 |   1 | 1
 2 | 1 | 1 | 123 | 456 |  
 0 | 0 | 0 |   1 |   1 |  
 1 |   | 1 | 123 | 456 |  
 1 | 1 |   |   0 |   0 | 0
 2 | 1 | 1 |   1 |   1 | 1
 0 | 0 | 0 |   1 |   1 | 1
 2 |   | 1 |   1 |     | 1
 2 | 1 | 1 |   1 |     | 1
 1 | 1 | 1 |   0 |   0 | 0
 1 | 1 | 0 | 123 | 456 |  
 0 | 0 | 0 | 123 | 456 |  
 2 | 1 | 1 |   1 |   1 |  
 2 |   | 1 |   1 |   1 |  
 1 | 1 | 0 |   0 |   0 | 0
 1 |   | 1 |   0 |   0 | 0
 2 |   | 1 |   0 |   0 | 0
 0 | 0 | 0 |   1 |     | 1
 1 | 1 |   | 123 | 456 |  
 2 | 1 | 1 |   1 |   1 | 0
 2 | 1 | 1 |   0 |   0 | 0
 2 |   | 1 |   1 |   1 | 0
 1 | 1 | 1 | 123 | 456 |  
 0 | 0 | 0 |   1 |   1 | 0
 2 |   | 1 | 123 | 456 |  
(25 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t3_subq.a from t3_subq);
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  HashAggregate
         Group Key: (RowIdExpr)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: (RowIdExpr)
               ->  Nested Loop
                     Join Filter: ((t1_subq.a <> t2_subq.a) OR (t2_subq.a <> t3_subq.a))
                     ->  Broadcast Motion 3:3  (slice3; segments: 3)
                           ->  Nested Loop
                                 ->  Broadcast Motion 3:3  (slice4; segments: 3)
                                       ->  Seq Scan on t2_subq
                                 ->  Materialize
                                       ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(16 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t3_subq.a from t3_subq);
 a | b | c |  a  |  b  | c 
---+---+---+-----+-----+---
 1 | 1 | 1 |   0 |   0 | 0
 2 |   | 1 |   1 |     | 1
 2 | 1 | 1 |   1 |     | 1
 1 | 1 | 0 | 123 | 456 |  
 1 | 1 | 0 |   0 |   0 | 0
 1 | 1 |   |   0 |   0 | 0
 1 |   | 1 |   1 |   1 |  
 1 |   | 1 | 123 | 456 |  
 1 |   | 1 |   1 |   1 | 1
 1 | 1 |   | 123 | 456 |  
 1 |   | 1 |   0 |   0 | 0
 1 | 1 | 1 |   1 |   1 | 1
 2 | 1 | 1 |   1 |   1 |  
 1 | 1 | 0 |   1 |   1 | 0
 2 |   | 1 |   1 |   1 | 1
 0 | 0 | 0 | 123 | 456 |  
 2 | 1 | 1 | 123 | 456 |  
 1 | 1 | 1 |   1 |   1 | 0
 1 |   | 1 |   1 |   1 | 0
 1 | 1 |   |   1 |   1 | 0
 1 |   | 1 |   1 |     | 1
 0 | 0 | 0 |   1 |   1 |  
 0 | 0 | 0 |   1 |     | 1
 2 | 1 | 1 |   1 |   1 | 1
 1 | 1 | 1 |   1 |     | 1
 1 | 1 | 1 | 123 | 456 |  
 2 |   | 1 |   0 |   0 | 0
 0 | 0 | 0 |   0 |   0 | 0
 1 | 1 | 0 |   1 |   1 |  
 2 | 1 | 1 |   1 |   1 | 0
 2 | 1 | 1 |   0 |   0 | 0
 1 | 1 |   |   1 |   1 | 1
 1 | 1 | 0 |   1 |     | 1
 2 |   | 1 |   1 |   1 |  
 0 | 0 | 0 |   1 |   1 | 0
 0 | 0 | 0 |   1 |   1 | 1
 1 | 1 | 1 |   1 |   1 |  
 1 | 1 |   |   1 |   1 |  
 1 | 1 |   |   1 |     | 1
 1 | 1 | 0 |   1 |   1 | 1
 2 |   | 1 |   1 |   1 | 0
 2 |   | 1 | 123 | 456 |  
(42 rows)

    -- subquery in value context
explain (costs off) select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t1_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t1_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 
 f
 
 f
 f
 f
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) != ANY (select t2_subq.a, t2_subq.b from t2_subq)) from t1_subq;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                       ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(7 rows)

select ((t1_subq.a, t1_subq.b) != ANY (select t2_subq.a, t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t2_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 
 t
 t
 t
 t
 
(7 rows)

explain (costs off)  select ((a, b) != ANY (select (item).a, (item).b from composite_table)) from t1_subq;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                       ->  Seq Scan on composite_table
 Optimizer: Postgres-based planner
(7 rows)

select ((a, b) != ANY (select (item).a, (item).b from composite_table)) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) != ANY (select a, b from t3_subq) from t1_subq, t2_subq;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice3; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                       ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(11 rows)

select (t1_subq.a, t2_subq.a) != ANY (select a, b from t3_subq) from t1_subq, t2_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
(42 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t1_subq.a from t3_subq) from t1_subq, t2_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice3; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(12 rows)

select (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t1_subq.a from t3_subq) from t1_subq, t2_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 f
 f
 f
 f
 t
 f
 f
 f
 f
 t
 f
 f
 f
 f
 t
 f
 f
 f
 f
 t
 t
 t
 t
 t
 f
 t
 t
 t
 t
 t
(42 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t3_subq.a from t3_subq) from t1_subq, t2_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice3; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(12 rows)

select (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t3_subq.a from t3_subq) from t1_subq, t2_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
(42 rows)

-- Three columns composite key
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq);
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         ->  Seq Scan on t1_subq
               Filter: ((a <> b) OR (b <> c) OR (c <> b))
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq);
 a | b | c 
---+---+---
 2 | 1 | 1
 1 | 1 | 0
(2 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b) OR (t1_subq.c <> t2_subq.c))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq);
 a | b | c 
---+---+---
 2 | 1 | 1
 2 |   | 1
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(7 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> t1_subq.b) OR (t1_subq.b <> t1_subq.c) OR (t1_subq.c <> t2_subq.b))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq);
 a | b | c 
---+---+---
 2 | 1 | 1
 2 |   | 1
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(6 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 
 
 
 f
 t
 f
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq)) from t1_subq;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                       ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(7 rows)

select  ((t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 t
 
 t
 t
 t
 t
(7 rows)

-- Adding const to projection column
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.c+1, t1_subq.c+1 from t2_subq);
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         ->  Seq Scan on t1_subq
               Filter: ((a <> (c + 1)) OR (b <> (c + 1)))
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.c+1, t1_subq.c+1 from t2_subq);
 a | b | c 
---+---+---
 1 |   | 1
 1 | 1 | 1
 0 | 0 | 0
 2 | 1 | 1
(4 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.c+1, t2_subq.c+1 from t2_subq);
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> (t2_subq.c + 1)) OR (t1_subq.b <> (t2_subq.c + 1)))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.c+1, t2_subq.c+1 from t2_subq);
 a | b | c 
---+---+---
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
 2 | 1 | 1
 2 |   | 1
(7 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+1, t2_subq.b+1 from t2_subq);
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> (t1_subq.a + 1)) OR (t1_subq.b <> (t2_subq.b + 1)))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+1, t2_subq.b+1 from t2_subq);
 a | b | c 
---+---+---
 2 | 1 | 1
 2 |   | 1
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(7 rows)

    -- subquery in value context
explain (costs off) select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.c+1, t1_subq.c+1 from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.c+1, t1_subq.c+1 from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 
 
 t
 t
 f
 t
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) != ANY (select t2_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                       ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(7 rows)

select ((t1_subq.a, t1_subq.b) != ANY (select t2_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 
 t
 t
 t
 t
 t
(7 rows)

-- Adding two columns
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq);
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         ->  Seq Scan on t1_subq
               Filter: ((a <> (a + a)) OR (b <> (b + b)))
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq);
 a | b | c 
---+---+---
 2 | 1 | 1
 2 |   | 1
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
(6 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> (t2_subq.a + t2_subq.a)) OR (t1_subq.b <> (t2_subq.b + t2_subq.b)))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq);
 a | b | c 
---+---+---
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
 2 | 1 | 1
 2 |   | 1
(7 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> (t1_subq.a + t2_subq.a)) OR (t1_subq.b <> (t1_subq.b + t2_subq.b)))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq);
 a | b | c 
---+---+---
 2 | 1 | 1
 2 |   | 1
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(7 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 f
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b) != ANY (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq)) from t1_subq;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                       ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(7 rows)

select  ((t1_subq.a, t1_subq.b) != ANY (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq)) from t1_subq;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

-- Nested subquery
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a,t1_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Hash Semi Join
                                   Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                                   ->  Seq Scan on t2_subq
                                   ->  Hash
                                         ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(13 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a,t1_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Result
         ->  Unique
               Group Key: (RowIdExpr)
               ->  Sort
                     Sort Key: (RowIdExpr)
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)
                           Hash Key: (RowIdExpr)
                           ->  Nested Loop
                                 Join Filter: ((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b))
                                 ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                       ->  Seq Scan on t1_subq
                                 ->  Materialize
                                       ->  Hash Semi Join
                                             Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                                             ->  Seq Scan on t2_subq
                                             ->  Hash
                                                   ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(19 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 0
 2 | 1 | 1
 2 |   | 1
 1 |   | 1
 1 | 1 | 1
 0 | 0 | 0
(7 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq));
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Hash Semi Join
                 Hash Cond: (t2_subq.a = t3_subq.a)
                 ->  Result
                       Filter: (t2_subq.b = t1_subq.b)
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   ->  Seq Scan on t2_subq
                 ->  Hash
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                   ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(16 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq));
 a | b | c 
---+---+---
 2 | 1 | 1
(1 row)

    -- subquery in value context
explain (costs off) select (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq)) from t1_subq;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                       ->  Hash Semi Join
                             Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                             ->  Seq Scan on t2_subq
                             ->  Hash
                                   ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(11 rows)

select (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq)) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

explain (costs off) select (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq)) from t1_subq;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Hash Semi Join
                 Hash Cond: (t2_subq.a = t3_subq.a)
                 ->  Result
                       Filter: (t2_subq.b = t1_subq.b)
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   ->  Seq Scan on t2_subq
                 ->  Hash
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                   ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(15 rows)

select (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq)) from t1_subq;
 ?column? 
----------
 t
 f
 f
 f
 f
 f
 f
(7 rows)

-- Set returning function in projection
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select generate_series(1, 10), generate_series(1, 10));
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> (generate_series(1, 10))) OR (t1_subq.b <> (generate_series(1, 10))))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  ProjectSet
                     ->  Result
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select generate_series(1, 10), generate_series(1, 10));
 a | b | c 
---+---+---
 2 | 1 | 1
 2 |   | 1
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(7 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b) != ANY (select generate_series(1, 10), generate_series(1, 10))) from t1_subq;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Materialize
                 ->  ProjectSet
                       ->  Result
 Optimizer: Postgres-based planner
(7 rows)

select  ((t1_subq.a, t1_subq.b) != ANY (select generate_series(1, 10), generate_series(1, 10))) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

reset optimizer_trace_fallback;
