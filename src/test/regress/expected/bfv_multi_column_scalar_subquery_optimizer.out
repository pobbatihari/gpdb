-----------------------------------------------
-- Testcases regarding multi-column scalar subqueries --
-----------------------------------------------
-- Setup
-- start_ignore
drop table if exists t1_subq;
NOTICE:  table "t1_subq" does not exist, skipping
drop table if exists t2_subq;
NOTICE:  table "t2_subq" does not exist, skipping
drop table if exists t3_subq;
NOTICE:  table "t3_subq" does not exist, skipping
drop table if exists composite_table;
NOTICE:  table "composite_table" does not exist, skipping
create table t1_subq (a int, b int, c int) distributed by (a);
create table t2_subq (a int, b int, c int) distributed by (a);
create table t3_subq (a int, b int, c int) distributed by (a);
create type composite_type as ( a int, b int);
create table composite_table(id int, item composite_type) distributed by (id);
-- end_ignore
insert into t1_subq values (1, 1, null), (2, 1, 1), (1, null, 1), (2, null, 1), (1,1,1), (1,1,0), (0,0,0);
insert into t2_subq values (1, null, 1), ('123', 456, null), (1, 1, null), (1, 1, 1), (1, 1, 0), (0,0,0);
insert into t3_subq values (1, 1, null), ('123', 456, null), (1, 1, null);
insert into composite_table values (1, ROW(1, 10)), (2, ROW(2, 20));
analyze t1_subq, t2_subq, t3_subq;
set optimizer_trace_fallback to on;
----------------------------------------------------
------- multi-column scalar IN subqueries ----------
----------------------------------------------------
-- Two columns composite key
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.b, t1_subq.c from t2_subq);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: true
         ->  Seq Scan on t1_subq
               Filter: ((a = b) AND (b = c))
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Limit
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Limit
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.b, t1_subq.c from t2_subq);
 a | b | c 
---+---+---
 1 | 1 | 1
 0 | 0 | 0
(2 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a, t2_subq.b from t2_subq);
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: ((t1_subq.a = t2_subq.a) AND (t1_subq.b = t2_subq.b))
         ->  Seq Scan on t1_subq
         ->  Hash
               ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(7 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a, t2_subq.b from t2_subq);
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(4 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a, t1_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
                 QUERY PLAN                 
--------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: (t1_subq.a = t2_subq.a)
         ->  Seq Scan on t1_subq
               Filter: (b IS NOT NULL)
         ->  Hash
               ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a, t1_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(4 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.b, t1_subq.c from t2_subq) AND t1_subq.b=1;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: true
         ->  Seq Scan on t1_subq
               Filter: ((a = b) AND (b = c) AND (b = 1))
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Limit
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Limit
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.b, t1_subq.c from t2_subq) AND t1_subq.b=1;
 a | b | c 
---+---+---
 1 | 1 | 1
(1 row)

explain (costs off)  select * from t1_subq where (a, b) IN (select (item).a, (item).b from composite_table);
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: ((t1_subq.a = ((composite_table.item).a)) AND (t1_subq.b = ((composite_table.item).b)))
         ->  Seq Scan on t1_subq
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: ((composite_table.item).a)
                     ->  Seq Scan on composite_table
 Optimizer: GPORCA
(9 rows)

select * from t1_subq where (a, b) IN (select (item).a, (item).b from composite_table);
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) IN (select a, b from t3_subq);
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: ((t1_subq.a = t3_subq.a) AND (t2_subq.a = t3_subq.b))
         ->  Nested Loop
               Join Filter: true
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
               ->  Seq Scan on t1_subq
         ->  Hash
               ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(11 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) IN (select a, b from t3_subq);
 a | b | c | a | b | c 
---+---+---+---+---+---
 1 | 1 |   | 1 |   | 1
 1 |   | 1 | 1 |   | 1
 1 | 1 | 1 | 1 |   | 1
 1 | 1 | 0 | 1 |   | 1
 1 | 1 |   | 1 | 1 |  
 1 |   | 1 | 1 | 1 |  
 1 | 1 | 1 | 1 | 1 |  
 1 | 1 | 0 | 1 | 1 |  
 1 | 1 |   | 1 | 1 | 1
 1 |   | 1 | 1 | 1 | 1
 1 | 1 | 1 | 1 | 1 | 1
 1 | 1 | 0 | 1 | 1 | 1
 1 | 1 |   | 1 | 1 | 0
 1 |   | 1 | 1 | 1 | 0
 1 | 1 | 1 | 1 | 1 | 0
 1 | 1 | 0 | 1 | 1 | 0
(16 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t1_subq.a from t3_subq);
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1_subq.a = t2_subq.a)
         ->  Seq Scan on t1_subq
         ->  Hash
               ->  Nested Loop Semi Join
                     Join Filter: true
                     ->  Seq Scan on t2_subq
                     ->  Materialize
                           ->  Broadcast Motion 1:3  (slice2)
                                 ->  Limit
                                       ->  Gather Motion 3:1  (slice3; segments: 3)
                                             ->  Limit
                                                   ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(15 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t1_subq.a from t3_subq);
 a | b | c | a | b | c 
---+---+---+---+---+---
 1 | 1 |   | 1 | 1 | 0
 1 | 1 |   | 1 | 1 | 1
 1 | 1 |   | 1 | 1 |  
 1 | 1 |   | 1 |   | 1
 1 |   | 1 | 1 | 1 | 0
 1 |   | 1 | 1 | 1 | 1
 1 |   | 1 | 1 | 1 |  
 1 |   | 1 | 1 |   | 1
 1 | 1 | 1 | 1 | 1 | 0
 1 | 1 | 1 | 1 | 1 | 1
 1 | 1 | 1 | 1 | 1 |  
 1 | 1 | 1 | 1 |   | 1
 1 | 1 | 0 | 1 | 1 | 0
 1 | 1 | 0 | 1 | 1 | 1
 1 | 1 | 0 | 1 | 1 |  
 1 | 1 | 0 | 1 |   | 1
 0 | 0 | 0 | 0 | 0 | 0
(17 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t3_subq.a from t3_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
                    QUERY PLAN                    
--------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: (t1_subq.a = t3_subq.a)
         ->  Hash Join
               Hash Cond: (t1_subq.a = t2_subq.a)
               ->  Seq Scan on t1_subq
               ->  Hash
                     ->  Seq Scan on t2_subq
         ->  Hash
               ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(11 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t3_subq.a from t3_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
 a | b | c | a | b | c 
---+---+---+---+---+---
 1 | 1 |   | 1 | 1 | 0
 1 | 1 |   | 1 | 1 | 1
 1 | 1 |   | 1 | 1 |  
 1 | 1 |   | 1 |   | 1
 1 |   | 1 | 1 | 1 | 0
 1 |   | 1 | 1 | 1 | 1
 1 |   | 1 | 1 | 1 |  
 1 |   | 1 | 1 |   | 1
 1 | 1 | 1 | 1 | 1 | 0
 1 | 1 | 1 | 1 | 1 | 1
 1 | 1 | 1 | 1 | 1 |  
 1 | 1 | 1 | 1 |   | 1
 1 | 1 | 0 | 1 | 1 | 0
 1 | 1 | 0 | 1 | 1 | 1
 1 | 1 | 0 | 1 | 1 |  
 1 | 1 | 0 | 1 |   | 1
(16 rows)

    -- subquery in value context
explain (costs off) select ((t1_subq.a, t1_subq.b) IN (select t1_subq.a, t1_subq.b from t2_subq)) from t1_subq;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Aggregate
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(10 rows)

select ((t1_subq.a, t1_subq.b) IN (select t1_subq.a, t1_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 
 t
 
 t
 t
 t
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) IN (select t2_subq.a, t2_subq.b from t2_subq)) from t1_subq;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a = t2_subq.a) AND (t1_subq.b = t2_subq.b)) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(13 rows)

select ((t1_subq.a, t1_subq.b) IN (select t2_subq.a, t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 t
 t
 t
 t
 
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) IN (select t1_subq.a, t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) IN (select t1_subq.a, t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 t
 
 t
 
 t
 t
 t
(7 rows)

explain (costs off)  select ((a, b) IN (select (item).a, (item).b from composite_table)) from t1_subq;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a = ((composite_table.item).a)) AND (t1_subq.b = ((composite_table.item).b))) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Seq Scan on composite_table
 Optimizer: GPORCA
(13 rows)

select ((a, b) IN (select (item).a, (item).b from composite_table)) from t1_subq;
 ?column? 
----------
 f
 
 f
 f
 f
 f
 
(7 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) IN (select a, b from t3_subq) from t1_subq, t2_subq;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  HashAggregate
         Group Key: t1_subq.a, t1_subq.ctid, t1_subq.gp_segment_id, t2_subq.a, t2_subq.ctid, t2_subq.gp_segment_id
         ->  Nested Loop Left Join
               Join Filter: (((t1_subq.a = t3_subq.a) AND (t2_subq.a = t3_subq.b)) IS NOT FALSE)
               ->  Nested Loop
                     Join Filter: true
                     ->  Broadcast Motion 3:3  (slice3; segments: 3)
                           ->  Seq Scan on t2_subq
                     ->  Seq Scan on t1_subq
               ->  Materialize
                     ->  Result
                           ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                 ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(15 rows)

select (t1_subq.a, t2_subq.a) IN (select a, b from t3_subq) from t1_subq, t2_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 f
 t
 f
 t
 f
 f
 t
 f
 t
 f
 f
 f
 f
 t
 f
 t
 f
 t
 t
 t
 t
 f
 t
 f
 t
 t
 f
(42 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t1_subq.a from t3_subq) from t1_subq, t2_subq;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Nested Loop
               Join Filter: true
               ->  Broadcast Motion 3:3  (slice4; segments: 3)
                     ->  Seq Scan on t2_subq
               ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Aggregate
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(14 rows)

select (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t1_subq.a from t3_subq) from t1_subq, t2_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 f
 f
 f
 f
 t
 f
 f
 f
 f
 f
(42 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t3_subq.a from t3_subq) from t1_subq, t2_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice3; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(12 rows)

select (t1_subq.a, t2_subq.a) IN (select t2_subq.a, t3_subq.a from t3_subq) from t1_subq, t2_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
(42 rows)

-- Three columns composite key
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: true
         ->  Seq Scan on t1_subq
               Filter: ((a = b) AND (b = c) AND (c = b))
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Limit
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Limit
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq);
 a | b | c 
---+---+---
 1 | 1 | 1
 0 | 0 | 0
(2 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: ((t1_subq.a = t2_subq.a) AND (t1_subq.b = t2_subq.b) AND (t1_subq.c = t2_subq.c))
         ->  Seq Scan on t1_subq
         ->  Hash
               ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(7 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq);
 a | b | c 
---+---+---
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(3 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: (t1_subq.a = t2_subq.b)
         ->  Seq Scan on t1_subq
               Filter: ((a = b) AND (b = c))
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: t2_subq.b
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(10 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
 a | b | c 
---+---+---
 1 | 1 | 1
 0 | 0 | 0
(2 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq) AND t1_subq.b=1;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: true
         ->  Seq Scan on t1_subq
               Filter: ((a = b) AND (b = c) AND (c = b) AND (b = 1))
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Limit
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Limit
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq) AND t1_subq.b=1;
 a | b | c 
---+---+---
 1 | 1 | 1
(1 row)

    -- subquery in value context
explain (costs off) select ((t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq)) from t1_subq;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Aggregate
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(10 rows)

select ((t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 
 
 
 t
 f
 t
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b, t1_subq.c) IN (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq)) from t1_subq;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.c, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.c, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a = t2_subq.a) AND (t1_subq.b = t2_subq.b) AND (t1_subq.c = t2_subq.c)) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(13 rows)

select ((t1_subq.a, t1_subq.b, t1_subq.c) IN (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 t
 t
 t
 
 
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b, t1_subq.c) IN (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 f
 
 
 
 t
 f
 t
(7 rows)

-- Adding const to projection column
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.c+1, t1_subq.c+1 from t2_subq);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: true
         ->  Seq Scan on t1_subq
               Filter: ((a = (c + 1)) AND (b = (c + 1)))
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Limit
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Limit
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.c+1, t1_subq.c+1 from t2_subq);
 a | b | c 
---+---+---
 1 | 1 | 0
(1 row)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.c+1, t2_subq.c+1 from t2_subq);
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: ((t1_subq.a = ((t2_subq.c + 1))) AND (t1_subq.b = ((t2_subq.c + 1))))
         ->  Seq Scan on t1_subq
         ->  Hash
               ->  GroupAggregate
                     Group Key: ((t2_subq.c + 1)), ((t2_subq.c + 1))
                     ->  Sort
                           Sort Key: ((t2_subq.c + 1)), ((t2_subq.c + 1))
                           ->  Redistribute Motion 3:3  (slice2; segments: 3)
                                 Hash Key: ((t2_subq.c + 1))
                                 ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(13 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.c+1, t2_subq.c+1 from t2_subq);
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
(3 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a+1, t2_subq.b+1 from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
                            QUERY PLAN                            
------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: (t1_subq.b = (t2_subq.b + 1))
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: t1_subq.b
               ->  Seq Scan on t1_subq
                     Filter: (a = (a + 1))
         ->  Hash
               ->  Redistribute Motion 3:3  (slice3; segments: 3)
                     Hash Key: (t2_subq.b + 1)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a+1, t2_subq.b+1 from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
 a | b | c 
---+---+---
(0 rows)

    -- subquery in value context
explain (costs off) select ((t1_subq.a, t1_subq.b) IN (select t1_subq.c+1, t1_subq.c+1 from t2_subq)) from t1_subq;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Aggregate
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(10 rows)

select ((t1_subq.a, t1_subq.b) IN (select t1_subq.c+1, t1_subq.c+1 from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 
 
 f
 f
 t
 f
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) IN (select t2_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a = ((t2_subq.c + 1))) AND (t1_subq.b = ((t2_subq.c + 1)))) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(13 rows)

select ((t1_subq.a, t1_subq.b) IN (select t2_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
 ?column? 
----------
 
 
 
 t
 t
 t
 
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) IN (select t1_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) IN (select t1_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 t
 
 
 f
 f
 t
 f
(7 rows)

-- Adding two columns
   -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: true
         ->  Seq Scan on t1_subq
               Filter: ((a = (a + a)) AND (b = (b + b)))
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Limit
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Limit
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq);
 a | b | c 
---+---+---
 0 | 0 | 0
(1 row)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: ((t1_subq.a = ((t2_subq.a + t2_subq.a))) AND (t1_subq.b = ((t2_subq.b + t2_subq.b))))
         ->  Seq Scan on t1_subq
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: ((t2_subq.a + t2_subq.a))
                     ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq);
 a | b | c 
---+---+---
 0 | 0 | 0
(1 row)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  HashAggregate
         Group Key: (RowIdExpr)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: (RowIdExpr)
               ->  Nested Loop
                     Join Filter: (((t1_subq.a + t2_subq.a) = t1_subq.a) AND ((t1_subq.b + t2_subq.b) = t1_subq.b))
                     ->  Broadcast Motion 3:3  (slice3; segments: 3)
                           ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
 a | b | c 
---+---+---
 2 | 1 | 1
 0 | 0 | 0
 1 | 1 | 1
 1 | 1 | 0
 1 | 1 |  
(5 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b) = ANY(select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq)) from t1_subq;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Aggregate
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(10 rows)

select  ((t1_subq.a, t1_subq.b) = ANY(select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 t
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b) = ANY(select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq)) from t1_subq;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a = ((t2_subq.a + t2_subq.a))) AND (t1_subq.b = ((t2_subq.b + t2_subq.b)))) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(13 rows)

select  ((t1_subq.a, t1_subq.b) = ANY(select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 
 
 t
 f
 f
 f
 f
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b) = ANY(select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b) = ANY(select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 t
 
 t
 
 t
 t
 t
(7 rows)

-- Nested subquery
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a,t1_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: true
         ->  Seq Scan on t1_subq
               Filter: ((a = a) AND (b = b))
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Limit
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Limit
                                       ->  Hash Semi Join
                                             Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                                             ->  Seq Scan on t2_subq
                                             ->  Hash
                                                   ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(16 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t1_subq.a,t1_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
 a | b | c 
---+---+---
 2 | 1 | 1
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(5 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: ((t1_subq.a = t2_subq.a) AND (t1_subq.b = t2_subq.b))
         ->  Seq Scan on t1_subq
         ->  Hash
               ->  Hash Semi Join
                     Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                     ->  Seq Scan on t2_subq
                     ->  Hash
                           ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(11 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
(3 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq));
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Hash Semi Join
                 Hash Cond: (t2_subq.a = t3_subq.a)
                 ->  Result
                       Filter: (t2_subq.b = t1_subq.b)
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   ->  Seq Scan on t2_subq
                 ->  Hash
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                   ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(16 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq));
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
(3 rows)

    -- subquery in value context
explain (costs off) select (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq)) from t1_subq;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a = t2_subq.a) AND (t1_subq.b = t2_subq.b)) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Hash Semi Join
                                             Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                                             ->  Seq Scan on t2_subq
                                             ->  Hash
                                                   ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(17 rows)

select (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 t
 t
 t
 
(7 rows)

explain (costs off) select (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Hash Semi Join
                 Hash Cond: (t2_subq.a = t3_subq.a)
                 ->  Result
                       Filter: (t2_subq.b = t1_subq.b)
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   ->  Seq Scan on t2_subq
                 ->  Hash
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                   ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(15 rows)

select (t1_subq.a, t1_subq.b) IN (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 f
 f
 t
 f
 t
 t
 f
(7 rows)

-- Set returning function in projection
   -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select generate_series(1, 10), generate_series(1, 10));
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Semi Join
         Hash Cond: ((a = (generate_series(1, 10))) AND (b = (generate_series(1, 10))))
         ->  Seq Scan on t1_subq
         ->  Hash
               ->  ProjectSet
                     ->  Result
 Optimizer: GPORCA
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) IN (select generate_series(1, 10), generate_series(1, 10));
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
(3 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b) IN (select generate_series(1, 10), generate_series(1, 10))) from t1_subq;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: a, b, ctid, gp_segment_id
         ->  Sort
               Sort Key: a, b, ctid, gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((a = (generate_series(1, 10))) AND (b = (generate_series(1, 10)))) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  ProjectSet
                                 ->  Result
 Optimizer: GPORCA
(12 rows)

select  ((t1_subq.a, t1_subq.b) IN (select generate_series(1, 10), generate_series(1, 10))) from t1_subq;
 ?column? 
----------
 f
 
 f
 t
 t
 t
 
(7 rows)

-----------------------------------------------------
------- multi-column scalar ALL subqueries ----------
-----------------------------------------------------
-- Two columns composite key
   -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t1_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t1_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 a | b | c 
---+---+---
 2 | 1 | 1
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(5 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a, t2_subq.b from t2_subq);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a, t2_subq.b from t2_subq);
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 a | b | c 
---+---+---
(0 rows)

explain (costs off)  select * from t1_subq where (a, b) = ALL (select (item).a, (item).b from composite_table);
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((t1_subq.a <> ((composite_table.item).a)) OR (t1_subq.b <> ((composite_table.item).b)))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on composite_table
 Optimizer: GPORCA
(8 rows)

select * from t1_subq where (a, b) = ALL (select (item).a, (item).b from composite_table);
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) = ALL (select a, b from t3_subq);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((t1_subq.a <> t3_subq.a) OR (t2_subq.a <> t3_subq.b))
         ->  Nested Loop
               Join Filter: true
               ->  Broadcast Motion 3:3  (slice3; segments: 3)
                     ->  Seq Scan on t2_subq
               ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(12 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) = ALL (select a, b from t3_subq);
 a | b | c | a | b | c 
---+---+---+---+---+---
(0 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t1_subq.a from t3_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         Join Filter: (SubPlan 1)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice3; segments: 3)
                             ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(13 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t1_subq.a from t3_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 a | b | c | a | b | c 
---+---+---+---+---+---
 1 | 1 |   | 1 |   | 1
 1 |   | 1 | 1 |   | 1
 1 | 1 | 1 | 1 |   | 1
 1 | 1 | 0 | 1 |   | 1
 1 | 1 |   | 1 | 1 |  
 1 |   | 1 | 1 | 1 |  
 1 | 1 | 1 | 1 | 1 |  
 1 | 1 | 0 | 1 | 1 |  
 1 | 1 |   | 1 | 1 | 1
 1 |   | 1 | 1 | 1 | 1
 1 | 1 | 1 | 1 | 1 | 1
 1 | 1 | 0 | 1 | 1 | 1
 1 | 1 |   | 1 | 1 | 0
 1 |   | 1 | 1 | 1 | 0
 1 | 1 | 1 | 1 | 1 | 0
 1 | 1 | 0 | 1 | 1 | 0
 0 | 0 | 0 | 0 | 0 | 0
(17 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t3_subq.a from t3_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         Join Filter: (SubPlan 1)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice3; segments: 3)
                             ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(13 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t3_subq.a from t3_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 a | b | c | a | b | c 
---+---+---+---+---+---
(0 rows)

    -- subquery in value context
explain (costs off) select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t1_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t1_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 t
 
 t
 
 t
 t
 t
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) = ALL (select t2_subq.a, t2_subq.b from t2_subq)) from t1_subq;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b)) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(13 rows)

select ((t1_subq.a, t1_subq.b) = ALL (select t2_subq.a, t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a, t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 f
 
 f
 
 f
 f
 f
(7 rows)

explain (costs off) select ((a, b) = ALL (select (item).a, (item).b from composite_table)) from t1_subq;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a <> ((composite_table.item).a)) OR (t1_subq.b <> ((composite_table.item).b))) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Seq Scan on composite_table
 Optimizer: GPORCA
(13 rows)

select ((a, b) = ALL (select (item).a, (item).b from composite_table)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) = ALL (select a, b from t3_subq) from t1_subq, t2_subq;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  HashAggregate
         Group Key: t1_subq.a, t1_subq.ctid, t1_subq.gp_segment_id, t2_subq.a, t2_subq.ctid, t2_subq.gp_segment_id
         ->  Nested Loop Left Join
               Join Filter: (((t1_subq.a <> t3_subq.a) OR (t2_subq.a <> t3_subq.b)) IS NOT FALSE)
               ->  Nested Loop
                     Join Filter: true
                     ->  Broadcast Motion 3:3  (slice3; segments: 3)
                           ->  Seq Scan on t2_subq
                     ->  Seq Scan on t1_subq
               ->  Materialize
                     ->  Result
                           ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                 ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(15 rows)

select (t1_subq.a, t2_subq.a) = ALL (select a, b from t3_subq) from t1_subq, t2_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
(42 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t1_subq.a from t3_subq) from t1_subq, t2_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice3; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(12 rows)

select (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t1_subq.a from t3_subq) from t1_subq, t2_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 t
 t
 t
 t
 f
 f
 f
 f
 f
 t
 f
 f
 f
 f
 f
(42 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t3_subq.a from t3_subq) from t1_subq, t2_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice3; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(12 rows)

select (t1_subq.a, t2_subq.a) = ALL (select t2_subq.a, t3_subq.a from t3_subq) from t1_subq, t2_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
 f
(42 rows)

-- Three columns composite key
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 a | b | c 
---+---+---
 1 | 1 | 1
 0 | 0 | 0
(2 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b) OR (t1_subq.c <> t2_subq.c))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq);
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 a | b | c 
---+---+---
(0 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 f
 
 
 
 t
 f
 t
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq)) from t1_subq;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.c, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.c, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b) OR (t1_subq.c <> t2_subq.c)) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(13 rows)

select  ((t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b, t1_subq.c) = ALL (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 f
 f
 
 f
 f
 f
 f
(7 rows)

-- Adding const to projection column
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL(select t1_subq.c+1, t1_subq.c+1 from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL(select t1_subq.c+1, t1_subq.c+1 from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 a | b | c 
---+---+---
 1 | 1 | 0
(1 row)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL(select t2_subq.c+1, t2_subq.c+1 from t2_subq);
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((t1_subq.a <> ((t2_subq.c + 1))) OR (t1_subq.b <> ((t2_subq.c + 1))))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Result
                     ->  Broadcast Motion 3:3  (slice2; segments: 3)
                           ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL(select t2_subq.c+1, t2_subq.c+1 from t2_subq);
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL(select t1_subq.a+1, t2_subq.b+1 from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL(select t1_subq.a+1, t2_subq.b+1 from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 a | b | c 
---+---+---
(0 rows)

    -- subquery in value context
explain (costs off) select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.c+1, t1_subq.c+1 from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.c+1, t1_subq.c+1 from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 
 f
 f
 t
 f
 f
 
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) = ALL (select t2_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a <> ((t2_subq.c + 1))) OR (t1_subq.b <> ((t2_subq.c + 1)))) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(13 rows)

select ((t1_subq.a, t1_subq.b) = ALL (select t2_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 f
 
 f
 f
 f
 f
 f
(7 rows)

-- Adding two columns
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 a | b | c 
---+---+---
 0 | 0 | 0
(1 row)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq);
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((t1_subq.a <> ((t2_subq.a + t2_subq.a))) OR (t1_subq.b <> ((t2_subq.b + t2_subq.b))))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq);
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 a | b | c 
---+---+---
(0 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 t
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b) = ALL (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq)) from t1_subq;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a <> ((t2_subq.a + t2_subq.a))) OR (t1_subq.b <> ((t2_subq.b + t2_subq.b)))) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(13 rows)

select  ((t1_subq.a, t1_subq.b) = ALL (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b) = ALL (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

-- Nested subquery
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a,t1_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Hash Semi Join
                                   Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                                   ->  Seq Scan on t2_subq
                                   ->  Hash
                                         ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(13 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t1_subq.a,t1_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 a | b | c 
---+---+---
 2 | 1 | 1
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(5 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Semi Join
                           Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                           ->  Seq Scan on t2_subq
                           ->  Hash
                                 ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq));
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Hash Semi Join
                 Hash Cond: (t2_subq.a = t3_subq.a)
                 ->  Result
                       Filter: (t2_subq.b = t1_subq.b)
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   ->  Seq Scan on t2_subq
                 ->  Hash
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                   ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(16 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq));
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 a | b | c 
---+---+---
 2 |   | 1
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(6 rows)

    -- subquery in value context
explain (costs off) select (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq)) from t1_subq;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b)) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Hash Semi Join
                                             Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                                             ->  Seq Scan on t2_subq
                                             ->  Hash
                                                   ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(17 rows)

select (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq)) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

explain (costs off) select (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Hash Semi Join
                 Hash Cond: (t2_subq.a = t3_subq.a)
                 ->  Result
                       Filter: (t2_subq.b = t1_subq.b)
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   ->  Seq Scan on t2_subq
                 ->  Hash
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                   ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(15 rows)

select (t1_subq.a, t1_subq.b) = ALL (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 t
 t
 t
 t
 t
 f
 t
(7 rows)

-- Set returning function in projection
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select generate_series(1, 10), generate_series(1, 10));
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Anti Semi (Not-In) Join
         Join Filter: ((a <> (generate_series(1, 10))) OR (b <> (generate_series(1, 10))))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  ProjectSet
                     ->  Result
 Optimizer: GPORCA
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) = ALL (select generate_series(1, 10), generate_series(1, 10));
 a | b | c 
---+---+---
(0 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b) = ALL (select generate_series(1, 10), generate_series(1, 10))) from t1_subq;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: a, b, ctid, gp_segment_id
         ->  Sort
               Sort Key: a, b, ctid, gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((a <> (generate_series(1, 10))) OR (b <> (generate_series(1, 10)))) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  ProjectSet
                                 ->  Result
 Optimizer: GPORCA
(12 rows)

select  ((t1_subq.a, t1_subq.b) = ALL (select generate_series(1, 10), generate_series(1, 10))) from t1_subq;
 ?column? 
----------
 f
 f
 f
 f
 f
 f
 f
(7 rows)

--------------------------------------------------------
------- multi-column scalar != ANY subqueries ----------
--------------------------------------------------------
-- Two columns composite key
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t1_subq.b from t2_subq);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: true
         ->  Seq Scan on t1_subq
               Filter: ((a <> a) OR (b <> b))
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Limit
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Limit
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t1_subq.b from t2_subq);
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a, t2_subq.b from t2_subq);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a, t2_subq.b from t2_subq);
 a | b | c 
---+---+---
 2 | 1 | 1
 2 |   | 1
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(7 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> t1_subq.a) OR (t1_subq.b <> t2_subq.b))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
 2 | 1 | 1
(5 rows)

explain (costs off)  select * from t1_subq where (a, b) != any(select (item).a, (item).b from composite_table);
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.c, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.ctid, t1_subq.gp_segment_id
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: t1_subq.ctid, t1_subq.gp_segment_id
                     ->  Nested Loop
                           Join Filter: ((t1_subq.a <> ((composite_table.item).a)) OR (t1_subq.b <> ((composite_table.item).b)))
                           ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                 ->  Seq Scan on composite_table
                           ->  Seq Scan on t1_subq
 Optimizer: GPORCA
(13 rows)

select * from t1_subq where (a, b) != any(select (item).a, (item).b from composite_table);
 a | b | c 
---+---+---
 2 | 1 | 1
 1 |   | 1
 1 | 1 | 1
 1 | 1 |  
 1 | 1 | 0
 2 |   | 1
 0 | 0 | 0
(7 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) != ANY (select a, b from t3_subq);
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> t3_subq.a) OR (t2_subq.a <> t3_subq.b))
         ->  Nested Loop
               Join Filter: true
               ->  Broadcast Motion 3:3  (slice3; segments: 3)
                     ->  Seq Scan on t2_subq
               ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(12 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) != ANY (select a, b from t3_subq);
 a | b | c |  a  |  b  | c 
---+---+---+-----+-----+---
 2 | 1 | 1 |   1 |     | 1
 2 |   | 1 |   1 |     | 1
 2 | 1 | 1 |   1 |   1 |  
 2 |   | 1 |   1 |   1 |  
 2 | 1 | 1 |   1 |   1 | 1
 2 |   | 1 |   1 |   1 | 1
 2 | 1 | 1 |   1 |   1 | 0
 2 |   | 1 |   1 |   1 | 0
 2 | 1 | 1 |   0 |   0 | 0
 2 |   | 1 |   0 |   0 | 0
 2 | 1 | 1 | 123 | 456 |  
 2 |   | 1 | 123 | 456 |  
 1 | 1 |   |   1 |     | 1
 1 |   | 1 |   1 |     | 1
 1 | 1 | 1 |   1 |     | 1
 1 | 1 | 0 |   1 |     | 1
 0 | 0 | 0 |   1 |     | 1
 1 | 1 |   |   1 |   1 |  
 1 |   | 1 |   1 |   1 |  
 1 | 1 | 1 |   1 |   1 |  
 1 | 1 | 0 |   1 |   1 |  
 0 | 0 | 0 |   1 |   1 |  
 1 | 1 |   |   1 |   1 | 1
 1 |   | 1 |   1 |   1 | 1
 1 | 1 | 1 |   1 |   1 | 1
 1 | 1 | 0 |   1 |   1 | 1
 0 | 0 | 0 |   1 |   1 | 1
 1 | 1 |   |   1 |   1 | 0
 1 |   | 1 |   1 |   1 | 0
 1 | 1 | 1 |   1 |   1 | 0
 1 | 1 | 0 |   1 |   1 | 0
 0 | 0 | 0 |   1 |   1 | 0
 1 | 1 |   |   0 |   0 | 0
 1 |   | 1 |   0 |   0 | 0
 1 | 1 | 1 |   0 |   0 | 0
 1 | 1 | 0 |   0 |   0 | 0
 0 | 0 | 0 |   0 |   0 | 0
 1 | 1 |   | 123 | 456 |  
 1 |   | 1 | 123 | 456 |  
 1 | 1 | 1 | 123 | 456 |  
 1 | 1 | 0 | 123 | 456 |  
 0 | 0 | 0 | 123 | 456 |  
(42 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t1_subq.a from t3_subq);
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         Join Filter: ((t1_subq.a <> t2_subq.a) OR (t2_subq.a <> t1_subq.a))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Nested Loop Semi Join
                           Join Filter: true
                           ->  Seq Scan on t2_subq
                           ->  Materialize
                                 ->  Broadcast Motion 1:3  (slice3)
                                       ->  Limit
                                             ->  Gather Motion 3:1  (slice4; segments: 3)
                                                   ->  Limit
                                                         ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(16 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t1_subq.a from t3_subq);
 a | b | c |  a  |  b  | c 
---+---+---+-----+-----+---
 2 | 1 | 1 | 123 | 456 |  
 2 | 1 | 1 |   1 |     | 1
 2 | 1 | 1 |   1 |   1 |  
 2 | 1 | 1 |   1 |   1 | 1
 2 | 1 | 1 |   1 |   1 | 0
 2 | 1 | 1 |   0 |   0 | 0
 2 |   | 1 | 123 | 456 |  
 2 |   | 1 |   1 |     | 1
 2 |   | 1 |   1 |   1 |  
 2 |   | 1 |   1 |   1 | 1
 2 |   | 1 |   1 |   1 | 0
 2 |   | 1 |   0 |   0 | 0
 1 | 1 |   | 123 | 456 |  
 1 | 1 |   |   0 |   0 | 0
 1 |   | 1 | 123 | 456 |  
 1 |   | 1 |   0 |   0 | 0
 1 | 1 | 1 | 123 | 456 |  
 1 | 1 | 1 |   0 |   0 | 0
 1 | 1 | 0 | 123 | 456 |  
 1 | 1 | 0 |   0 |   0 | 0
 0 | 0 | 0 | 123 | 456 |  
 0 | 0 | 0 |   1 |     | 1
 0 | 0 | 0 |   1 |   1 |  
 0 | 0 | 0 |   1 |   1 | 1
 0 | 0 | 0 |   1 |   1 | 0
(25 rows)

explain (costs off) select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t3_subq.a from t3_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  HashAggregate
         Group Key: (RowIdExpr)
         ->  Redistribute Motion 3:3  (slice2; segments: 3)
               Hash Key: (RowIdExpr)
               ->  Nested Loop
                     Join Filter: ((t1_subq.a <> t2_subq.a) OR (t2_subq.a <> t3_subq.a))
                     ->  Broadcast Motion 3:3  (slice3; segments: 3)
                           ->  Nested Loop
                                 ->  Broadcast Motion 3:3  (slice4; segments: 3)
                                       ->  Seq Scan on t2_subq
                                 ->  Materialize
                                       ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(16 rows)

select * from t1_subq, t2_subq where (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t3_subq.a from t3_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
 a | b | c |  a  |  b  | c 
---+---+---+-----+-----+---
 1 | 1 | 1 |   0 |   0 | 0
 2 |   | 1 |   1 |     | 1
 2 | 1 | 1 |   1 |     | 1
 1 | 1 | 0 | 123 | 456 |  
 1 | 1 | 0 |   0 |   0 | 0
 1 | 1 |   |   0 |   0 | 0
 1 |   | 1 |   1 |   1 |  
 1 |   | 1 | 123 | 456 |  
 1 |   | 1 |   1 |   1 | 1
 1 | 1 |   | 123 | 456 |  
 1 |   | 1 |   0 |   0 | 0
 1 | 1 | 1 |   1 |   1 | 1
 2 | 1 | 1 |   1 |   1 |  
 1 | 1 | 0 |   1 |   1 | 0
 2 |   | 1 |   1 |   1 | 1
 0 | 0 | 0 | 123 | 456 |  
 2 | 1 | 1 | 123 | 456 |  
 1 | 1 | 1 |   1 |   1 | 0
 1 |   | 1 |   1 |   1 | 0
 1 | 1 |   |   1 |   1 | 0
 1 |   | 1 |   1 |     | 1
 0 | 0 | 0 |   1 |   1 |  
 0 | 0 | 0 |   1 |     | 1
 2 | 1 | 1 |   1 |   1 | 1
 1 | 1 | 1 |   1 |     | 1
 1 | 1 | 1 | 123 | 456 |  
 2 |   | 1 |   0 |   0 | 0
 0 | 0 | 0 |   0 |   0 | 0
 1 | 1 | 0 |   1 |   1 |  
 2 | 1 | 1 |   1 |   1 | 0
 2 | 1 | 1 |   0 |   0 | 0
 1 | 1 |   |   1 |   1 | 1
 1 | 1 | 0 |   1 |     | 1
 2 |   | 1 |   1 |   1 |  
 0 | 0 | 0 |   1 |   1 | 0
 0 | 0 | 0 |   1 |   1 | 1
 1 | 1 | 1 |   1 |   1 |  
 1 | 1 |   |   1 |   1 |  
 1 | 1 |   |   1 |     | 1
 1 | 1 | 0 |   1 |   1 | 1
 2 |   | 1 |   1 |   1 | 0
 2 |   | 1 | 123 | 456 |  
(42 rows)

    -- subquery in value context
explain (costs off) select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t1_subq.b from t2_subq)) from t1_subq;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Aggregate
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(10 rows)

select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t1_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 f
 
 f
 
 f
 f
 f
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) != ANY (select t2_subq.a, t2_subq.b from t2_subq)) from t1_subq;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b)) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(13 rows)

select ((t1_subq.a, t1_subq.b) != ANY (select t2_subq.a, t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a, t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 t
 
 t
 
 t
 t
 t
(7 rows)

explain (costs off)  select ((a, b) != ANY (select (item).a, (item).b from composite_table)) from t1_subq;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a <> ((composite_table.item).a)) OR (t1_subq.b <> ((composite_table.item).b))) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Seq Scan on composite_table
 Optimizer: GPORCA
(13 rows)

select ((a, b) != ANY (select (item).a, (item).b from composite_table)) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) != ANY (select a, b from t3_subq) from t1_subq, t2_subq;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  HashAggregate
         Group Key: t1_subq.a, t1_subq.ctid, t1_subq.gp_segment_id, t2_subq.a, t2_subq.ctid, t2_subq.gp_segment_id
         ->  Nested Loop Left Join
               Join Filter: (((t1_subq.a <> t3_subq.a) OR (t2_subq.a <> t3_subq.b)) IS NOT FALSE)
               ->  Nested Loop
                     Join Filter: true
                     ->  Broadcast Motion 3:3  (slice3; segments: 3)
                           ->  Seq Scan on t2_subq
                     ->  Seq Scan on t1_subq
               ->  Materialize
                     ->  Result
                           ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                 ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(15 rows)

select (t1_subq.a, t2_subq.a) != ANY (select a, b from t3_subq) from t1_subq, t2_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
(42 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t1_subq.a from t3_subq) from t1_subq, t2_subq;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Nested Loop
               Join Filter: true
               ->  Broadcast Motion 3:3  (slice4; segments: 3)
                     ->  Seq Scan on t2_subq
               ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Aggregate
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(14 rows)

select (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t1_subq.a from t3_subq) from t1_subq, t2_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 f
 f
 f
 f
 t
 f
 f
 f
 f
 t
 f
 f
 f
 f
 t
 f
 f
 f
 f
 t
 t
 t
 t
 t
 f
 t
 t
 t
 t
 t
(42 rows)

explain (costs off) select (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t3_subq.a from t3_subq) from t1_subq, t2_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice3; segments: 3)
               ->  Seq Scan on t2_subq
         ->  Materialize
               ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(12 rows)

select (t1_subq.a, t2_subq.a) != ANY (select t2_subq.a, t3_subq.a from t3_subq) from t1_subq, t2_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
 t
(42 rows)

-- Three columns composite key
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: true
         ->  Seq Scan on t1_subq
               Filter: ((a <> b) OR (b <> c) OR (c <> b))
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Limit
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Limit
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq);
 a | b | c 
---+---+---
 1 | 1 | 0
 2 | 1 | 1
(2 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b) OR (t1_subq.c <> t2_subq.c))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq);
 a | b | c 
---+---+---
 2 | 1 | 1
 2 |   | 1
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(7 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> t1_subq.b) OR (t1_subq.b <> t1_subq.c) OR (t1_subq.c <> t2_subq.b))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
 a | b | c 
---+---+---
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
 2 | 1 | 1
 2 |   | 1
(6 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq)) from t1_subq;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Aggregate
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(10 rows)

select  ((t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t1_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 
 
 
 f
 t
 f
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq)) from t1_subq;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.c, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.c, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b) OR (t1_subq.c <> t2_subq.c)) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(13 rows)

select  ((t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t2_subq.a, t2_subq.b, t2_subq.c from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b, t1_subq.c) != ANY (select t1_subq.b, t1_subq.c, t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 t
 t
 
 t
 t
 t
 t
(7 rows)

-- Adding const to projection column
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.c+1, t1_subq.c+1 from t2_subq);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: true
         ->  Seq Scan on t1_subq
               Filter: ((a <> (c + 1)) OR (b <> (c + 1)))
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Limit
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Limit
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.c+1, t1_subq.c+1 from t2_subq);
 a | b | c 
---+---+---
 2 | 1 | 1
 1 |   | 1
 1 | 1 | 1
 0 | 0 | 0
(4 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.c+1, t2_subq.c+1 from t2_subq);
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> ((t2_subq.c + 1))) OR (t1_subq.b <> ((t2_subq.c + 1))))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Result
                     ->  Broadcast Motion 3:3  (slice2; segments: 3)
                           ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(9 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.c+1, t2_subq.c+1 from t2_subq);
 a | b | c 
---+---+---
 2 | 1 | 1
 2 |   | 1
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(7 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+1, t2_subq.b+1 from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> (t1_subq.a + 1)) OR (t1_subq.b <> (t2_subq.b + 1)))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+1, t2_subq.b+1 from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
 a | b | c 
---+---+---
 2 | 1 | 1
 2 |   | 1
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(7 rows)

    -- subquery in value context
explain (costs off) select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.c+1, t1_subq.c+1 from t2_subq)) from t1_subq;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Aggregate
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(10 rows)

select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.c+1, t1_subq.c+1 from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 
 
 t
 t
 f
 t
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) != ANY (select t2_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a <> ((t2_subq.c + 1))) OR (t1_subq.b <> ((t2_subq.c + 1)))) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(13 rows)

select ((t1_subq.a, t1_subq.b) != ANY (select t2_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

explain (costs off) select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.c+1, t2_subq.c+1 from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 t
 
 t
 t
 t
 t
 t
(7 rows)

-- Adding two columns
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq);
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: true
         ->  Seq Scan on t1_subq
               Filter: ((a <> (a + a)) OR (b <> (b + b)))
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Limit
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Limit
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(12 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq);
 a | b | c 
---+---+---
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 2 | 1 | 1
 2 |   | 1
(6 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq);
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> ((t2_subq.a + t2_subq.a))) OR (t1_subq.b <> ((t2_subq.b + t2_subq.b))))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq);
 a | b | c 
---+---+---
 2 | 1 | 1
 2 |   | 1
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
(7 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: ((t1_subq.a <> (t1_subq.a + t2_subq.a)) OR (t1_subq.b <> (t1_subq.b + t2_subq.b)))
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq);
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
 a | b | c 
---+---+---
 1 | 1 |  
 1 |   | 1
 1 | 1 | 1
 1 | 1 | 0
 0 | 0 | 0
 2 | 1 | 1
 2 |   | 1
(7 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq)) from t1_subq;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Left Join
         Join Filter: true
         ->  Seq Scan on t1_subq
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Aggregate
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(10 rows)

select  ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t1_subq.a, t1_subq.b+t1_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 f
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b) != ANY (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq)) from t1_subq;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a <> ((t2_subq.a + t2_subq.a))) OR (t1_subq.b <> ((t2_subq.b + t2_subq.b)))) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Seq Scan on t2_subq
 Optimizer: GPORCA
(13 rows)

select  ((t1_subq.a, t1_subq.b) != ANY (select t2_subq.a+t2_subq.a, t2_subq.b+t2_subq.b from t2_subq)) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

explain (costs off) select  ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Result
                 ->  Materialize
                       ->  Broadcast Motion 3:3  (slice2; segments: 3)
                             ->  Seq Scan on t2_subq
 Optimizer: Postgres-based planner
(8 rows)

select  ((t1_subq.a, t1_subq.b) != ANY (select t1_subq.a+t2_subq.a, t1_subq.b+t2_subq.b from t2_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

-- Nested subquery
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a,t1_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop Semi Join
         Join Filter: true
         ->  Seq Scan on t1_subq
               Filter: ((a <> a) OR (b <> b))
         ->  Materialize
               ->  Broadcast Motion 1:3  (slice2)
                     ->  Limit
                           ->  Gather Motion 3:1  (slice3; segments: 3)
                                 ->  Limit
                                       ->  Hash Semi Join
                                             Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                                             ->  Seq Scan on t2_subq
                                             ->  Hash
                                                   ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(16 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t1_subq.a,t1_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
 a | b | c 
---+---+---
(0 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.c, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.ctid, t1_subq.gp_segment_id
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: t1_subq.ctid, t1_subq.gp_segment_id
                     ->  Hash Semi Join
                           Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                           ->  Redistribute Motion 3:3  (slice3; segments: 3)
                                 Hash Key: t2_subq.a
                                 ->  Nested Loop
                                       Join Filter: ((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b))
                                       ->  Seq Scan on t1_subq
                                       ->  Materialize
                                             ->  Broadcast Motion 3:3  (slice4; segments: 3)
                                                   ->  Seq Scan on t2_subq
                           ->  Hash
                                 ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(20 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq));
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 0
 2 |   | 1
 0 | 0 | 0
 2 | 1 | 1
 1 |   | 1
 1 | 1 | 1
(7 rows)

explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq));
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         Filter: (SubPlan 1)
         SubPlan 1
           ->  Hash Semi Join
                 Hash Cond: (t2_subq.a = t3_subq.a)
                 ->  Result
                       Filter: (t2_subq.b = t1_subq.b)
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   ->  Seq Scan on t2_subq
                 ->  Hash
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                   ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(16 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq));
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: subplans with multi-column subqueries
 a | b | c 
---+---+---
 2 | 1 | 1
(1 row)

    -- subquery in value context
explain (costs off) select (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq)) from t1_subq;
                                                  QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
         ->  Sort
               Sort Key: t1_subq.a, t1_subq.b, t1_subq.ctid, t1_subq.gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((t1_subq.a <> t2_subq.a) OR (t1_subq.b <> t2_subq.b)) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  Result
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                       ->  Hash Semi Join
                                             Hash Cond: ((t2_subq.a = t3_subq.a) AND (t2_subq.b = t3_subq.b))
                                             ->  Seq Scan on t2_subq
                                             ->  Hash
                                                   ->  Seq Scan on t3_subq
 Optimizer: GPORCA
(17 rows)

select (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t3_subq.b from t3_subq)) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

explain (costs off) select (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1_subq
         SubPlan 1
           ->  Hash Semi Join
                 Hash Cond: (t2_subq.a = t3_subq.a)
                 ->  Result
                       Filter: (t2_subq.b = t1_subq.b)
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice2; segments: 3)
                                   ->  Seq Scan on t2_subq
                 ->  Hash
                       ->  Materialize
                             ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                   ->  Seq Scan on t3_subq
 Optimizer: Postgres-based planner
(15 rows)

select (t1_subq.a, t1_subq.b) != ANY (select t2_subq.a,t2_subq.b from t2_subq where (t2_subq.a, t2_subq.b) IN (select t3_subq.a, t1_subq.b from t3_subq)) from t1_subq;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because no plan has been computed for required properties in GPORCA
 ?column? 
----------
 f
 f
 f
 f
 f
 t
 f
(7 rows)

-- Set returning function in projection
    -- subquery in filter context
explain (costs off) select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select generate_series(1, 10), generate_series(1, 10));
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: a, b, c, ctid, gp_segment_id
         ->  Sort
               Sort Key: ctid, gp_segment_id
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: ctid, gp_segment_id
                     ->  Nested Loop
                           Join Filter: ((a <> (generate_series(1, 10))) OR (b <> (generate_series(1, 10))))
                           ->  ProjectSet
                                 ->  Result
                           ->  Seq Scan on t1_subq
 Optimizer: GPORCA
(13 rows)

select * from t1_subq where (t1_subq.a, t1_subq.b) != ANY (select generate_series(1, 10), generate_series(1, 10));
 a | b | c 
---+---+---
 1 | 1 |  
 1 | 1 | 0
 2 | 1 | 1
 1 |   | 1
 1 | 1 | 1
 2 |   | 1
 0 | 0 | 0
(7 rows)

    -- subquery in value context
explain (costs off) select  ((t1_subq.a, t1_subq.b) != ANY (select generate_series(1, 10), generate_series(1, 10))) from t1_subq;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  GroupAggregate
         Group Key: a, b, ctid, gp_segment_id
         ->  Sort
               Sort Key: a, b, ctid, gp_segment_id
               ->  Nested Loop Left Join
                     Join Filter: (((a <> (generate_series(1, 10))) OR (b <> (generate_series(1, 10)))) IS NOT FALSE)
                     ->  Seq Scan on t1_subq
                     ->  Materialize
                           ->  ProjectSet
                                 ->  Result
 Optimizer: GPORCA
(12 rows)

select  ((t1_subq.a, t1_subq.b) != ANY (select generate_series(1, 10), generate_series(1, 10))) from t1_subq;
 ?column? 
----------
 t
 t
 t
 t
 t
 t
 t
(7 rows)

reset optimizer_trace_fallback;
